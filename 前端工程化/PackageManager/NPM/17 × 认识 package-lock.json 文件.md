## package-lock.json

它是包依赖的“锁文件(lockfiles)”，位于项目（包）的根目录。

更新 `./node_modules` 目录下的依赖或 `package.json` 文件都会创建或更新 `package-lock.json` 文件。锁文件可以实时记录项目依赖树的最终结构，通过分发包的锁文件，可以在多人协作开发的场景下保持依赖环境的一致性。

推荐将 `package-lock.json` 文件提交到版本存储库中，它具有以下几个特点：

1. 存储依赖树的最终结构，以确保团队成员、部署环境、持续集成都能安装完全相同的依赖。
2. 可以加速依赖的安装，跳过对 `package.json` 依赖信息的解析。
3. 可以作为 `./node_modules` 目录的镜像文件。
4. 通过可读的源代码控制差异，更好地展示树变化的可视性

### lockfileVersion

包锁文件的版本：

- `npm 6.x` 及之前使用的锁文件版本号是 —— `1` 。
- `npm 7.x` - `npm 8.x` 使用的锁文件版本号是 —— `2` 。
- `npm9.x` ~ 使用的锁文件版本号是 —— `3` 。

版本号的差异内容在与记录内容的字段的不同：

- `lockfileVersion 1` : 没有 `packages` 字段，只有 `dependencies` 字段。
- `lockfileVersion 2` : 既有 `packages` 字段也有 `dependencies` 字段。
- `lockfileVersion 3` : 只有 `packages` 字段。

所以 `3` 兼容 `2` ， `2` 兼容 `1` ， `3` 不兼容 `2` 。

### packages

该字段只能被 `npm 7.x` 及其以上版本识别。

属性 `""` 专门用于存储包自身的信息。比如 `name` 、 `version`、`licence`、`dependencies`、`devDependencies`、`peerDependencies` 等。
```json
{
	"name": "pkg-ex",
	"packages":{
	  "":{
		  "name": "pkg-ex",
      "version": "1.0.0",
      "license": "ISC",
      "dependencies": {
        "lodash": "^4.17.21"
      },
      "devDependencies": {}	
		}
	}
}
```

其它依赖信息，则会用依赖的路径作为属性名 ，依赖的详细信息作为属性值，例如：
```json
{
  "name": "pkg-ex",
	"packages":{
		"node_modules/lodash": {
		 "version": "4.17.21",
		 "resolved": "<https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz>",
		 "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg=="
		}
	}
}
```

下面是一些关键的详细字段说明： 

**▪️ resolved**

包的解析路径，通常是 `tarball` 的 url 地址。

**▪️ integrity**

完整性。sha512

**▪️ link**

值是一个布尔值， `true` 表明依赖是通过符号链接的。此时 `resolved` 字段表示符号链接的目标地址。

**▪️ bin**

包的 `bin` 文件地址。

**▪️ dev,peer,optional**

依赖的具体类型。

**▪️ inBundle**

依赖是否是一个捆绑包。

**▪️ hasInstallScript**

指示包具有 `preinstall`、`install` 或 `postinstall` 脚本。

**▪️ hasShrinkwrap**

指示包具有 `npm-shrinkwrap.json` 文件。

### dependencies

`lockfileVersion 1` 中定义的字段，只会被 `npm 7.x` 及其以下版本使用(如果存在 `packages` 字段，`npm 7.x` 会忽略该字段)

与 `packages` 字段类似的键值对结构，但是以依赖的包名作为属性名，因为具有唯一性，因此很难表示符号链接的包。

## ./node_modules/.package-lock.json

包的隐藏锁文件。位于项目的 `./node_modules/` 目录下，内容上与 `package-lock.json` 文件基本相同，都记录了项目依赖树的完整信息，在满足特定条件下替代对整个 `node_modules` 目录的读取，旨提高 npm 处理依赖的性能。

只有以下条件被满足的情况下，npm 才会读取 `.package-lock.json` 文件。

1. 这个隐藏锁定文件引用的所有包文件夹都必须实际存在于 **`node_modules`** 目录中。
2. 隐藏锁定文件的修改时间至少要和其引用的所有包文件夹的修改时间一样新。

如果你使用其它包管理器（CLI）以任何方式修改了依赖树信息，都会使 npm 忽略该隐藏锁文件；如果你手动修改了 `node_modules` 目录中的文件，那么建议手动删除隐藏锁文件，因为手动修改（比如新增文件）可能并不会影响到包的修改时间。

## npm-shrinkwrap.json

`package-lock.json` 是 `npm5` 及以上版本新增的包锁文件， `npm-shrinkwrap.json` 是 `npm4` 及其之前版本旧的包锁文件。

**相同点：**

都是用来记录项目依赖树的完整结构（直接依赖 + 传递依赖）。在多人协作场景下提供一致的依赖环境

**不同点：**

- 项目如果同时存在这两个文件，优先使用 `npm-shrinkwrap.json` 文件。
- `npm5` 之后的版本需要手动执行 `npm shrinkwrap` 命令才会创建此文件。如果已经存在 `package-lock.json` 文件，执行 `npm shrinkwrap` 命令，则重命名 `package-lock.json` 文件为 `npm-shrinkwrap.json`
- `package-lock.json` 不会同包一起发布。 `npm-shrinkwrap.json` 可以被一同发布。

> 强烈建议包的发布者不要发布 `npm-shrinkwrap.json` 文件，因为这会阻止包的使用者对其项目的传递依赖更新的控制。

## **处理旧的锁文件**

当 npm 在包安装过程中检测到来自 `npm 6.x` 或更早版本的锁文件时，它会从 `node_modules` 树或npm 注册表中获取缺失的信息来更新旧的锁文件。