## 为什么需要“工作区”？

前置知识引入：[[15 × 调试包的技巧]]

**问题引入：**

使用`npm link` 或 `npm install ./` 命令可以将本地 npm 包链接到指定项目的 `./node_modules` 目录中，从而方便本地包的开发和调试工作。然而，当需要链接的本地 npm 包数量变多时，这种通过手动执行命令创建符号连接的方式将会捉襟见肘。此时便需要找到一种更加方便可靠的解决方案。而 npm 选择的方案便是 —— “工作区 (workspace) ”。

**npm 工作区是什么？**

工作区 是 `npm 7.x` 版本引入的一个新特性，它允许您使用一个顶级的根包来管理本地文件系统中的多个子包。在 npm 中，每个工作区都是一个 npm 包，有着自己的 `package.json` 文件，记录了该工作区特有的依赖信息；而根包的 `package.json` 文件则记录了根包的有关信息和所有工作区共享的依赖信息。

> “根包”与子包通常保存在同一个项目下，正是如此才能借助 Node.js 依赖路径解析规则，让多个子包共享根包的依赖。

**它解决了什么问题？**

npm 的工作区提供了一套更加标准的工作流程，它将对子包的链接过程作为标准安装依赖的一部分自动化完成。以替代手动执行 `npm link` 或 `npm install ./` 命令。除此之外，得益于将“根包”和“子包”紧密地组织在同一项目结构下，现在你可以使用同一条 npm 命令来对项目中的指定的子包或所有子包同时进行管理。

总的来说，工作区解决了如何在一个项目下管理多个可能具有相互依赖的本地 npm 包，更方便地实现在多个相关项目之间共享代码。

## 创建工作区

现在我们已经知道“工作区”是用于管理多个“子包”，并在多个项目（子包）之间共享代码。在项目中创建“工作区”非常简单，只需在根包的 `package.json` 文件中定义 `workspace:[]` 字段即可。

但这并不代表一个项目内的所有本地包都是工作区的子包，都接受工作区管理。只有那些事先加入到根包 `package.json#workspaces` 中的本地包，才能被工作区正确识别为子包。

给定一个项目 `app-mono` ，其目录结构如下：
```text
.
├── README.md
├── package.json
├── packages
│   ├── app1
│   └── app2
└── src
    └── index.mjs
```

现在要将项目下的 `app1` (packages/app1)与 `app2` (packages/app2)包加入到工作区中成为子包，只需要编辑根目录（根包）下的 `package.json` 文件的 `workspace` 字段即可：
```json
{
  "name": "app-mono",
  "version": "1.0.0",
  "private": true,
  "workspaces": [
    "packages/app1",
    "packages/app2"
  ],
  "scripts": {
    "test": "echo \\"This is app-mono root dir\\""
  },
   "keywords": []
  "license": "ISC",
}
```

根包主要是为了定义和管理工作区（子包），一般不会对外提供功能，所以通过将 `private` 字段设置为 `true`，可以防止根包被误发布到注册表中。

`workspaces` 字段也支持使用通配符来简化包的路径配置：
```json
{
	"workspaces": [ "packages/*" ],
}
```

此时 `packages` 目录下的所有 npm 包都会作为工作区的子包。

工作区可以很方便的管理多个子包，现在通过命令行进入到项目根路径下，执行下面的 npm 命令，便可以运行工作区中所有子包的的 `npm test` 命令。`—if-present` 参数则用于确保工作区存在该脚本命令时才会执行，以避免可能的报错。
```shell
npm test -ws --if-present
```

通过 `-w` 参数则可以执行工作区中指定子包的 `test` 命令：
```shell
npm test -w packages/app1
```

不论是工作区中的子包，还是来自注册表中的其它 npm 包。NPM 都遵循一致的版本范围语法。 对于工作区中相互依赖的子包，可以通过将依赖的版本范围语法修改为 `*` ，便可以一直使用最新的本地版本。
```json
{
    "name":"app2",
    "version":"1.0.0",
	"dependencies":{
		"@app-mono/app1":"*"
	}
}
```

除了在 `workspaces` 字段中手动创建工作区，还可以使用 `npm init` 命令在创建包时自动关联到工作区。
```shell
npm init -y -w packages/app3 --scope @app-mono
```

或者使用初始化器：
```shell
npm init react-app ./ -w packages/react-app --scope @app-mono
```

## 工作区命令选项

下面的工作区命令选项可以用于支持工作区的 NPM 命令。
### workspace

过滤工作区，将 npm 命令作用于指定的工作区。
简写为 `-w` 。
```shell
npm install --workspace packages/app1
npm ls -w packages/app2
```

### workspaces

将 npm 命令作用于指定的工作区。
简写为 `-ws`
```shell
npm outdated -ws
```

### include-workspace-root

为工作区执行 npm 命令时是否作用于“根包”。
```shell
npm test --if-present -ws --include-workspace-root true 
```
## 工作区的优势

1. **管理本地的多个包**
    工作区可以立即连接工作区下的的本地包，而无需重新发布和安装，这对跨多项目的开发和测试[^1]而言非常有帮助。npm CLI 还支持将命令作用于指定的工作区或应用于所有工作区。
    
2. **依赖共享**
    工作区的子包可以根据 Node.js 依赖路径解析规则共享根包的依赖。无需重复下载相同的依赖，以节省硬盘空间。
    
3. **代码重用**
    可以在不同项目间共享代码，减少重复工作，提升工作效率。
    
4. **一致性**
    工作区会统一所有子包的项目结构、依赖版本[^2]、构建流程[^3]、工具配置[^4]、脚本程序等。提高项目的可维护性。
    
5. **MonoRepo**
    开发者可以很方便的在同一个版本控制系统下对多个相关项目（工作区或子包）进行管理。
    包管理器的工作区技术是实现前端 MonoRepo 方案的核心。

## 工作区的劣势

1. **复杂性增加**
    对多工作区的管理、版本控制、CI/CD、依赖管理等。
    
2. **资源占用**
    MonoRepo 自然因素。构建时间与编译速度都会随着内容增加而变慢。
    
3. **重构困难**
    随着项目的增长，重构可能会变得更加复杂，因为改动可能会影响到多个相互依赖的工作区。
    
4. **权限和访问控制**
    在单个仓库中管理所有代码可能会使得细粒度的访问控制变得更加困难，这对于大型团队来说可能是一个问题。
    
5. **学习曲线**
    对于新加入的团队成员来说，理解和熟悉整个项目的结构和配置可能需要更多时间。
    
6. **隔离性问题：**
    一个工作区中的问题有可能影响到其他工作区，尤其是在共享资源和依赖的情况下。
    
7. **冲突风险增加**
    由于多个项目共享同一代码库，合并请求或推送操作可能会增加代码冲突的风险。

---
[^1]: 当你在一个项目中做出改变，而这个改变需要在另一个项目中进行测试时，工作区可以立即链接这些项目，无需发布和安装包的新版本

[^2]: 在多个项目中保持依赖关系一致，确保所有的工作区使用相同版本的共享依赖，避免版本冲突

[^3]: 在持续集成/持续部署中，工作区可以帮助自动化多个项目的构建和发布流程，因为它们都被集中管理。

[^4]: 以在根级别配置通用的linting、formatting和其他工具，这些配置将适用于所有工作区，从而确保一致性和减少配置重复